import { Payment, PaymentStatus, PaymentMethod } from '../../domain/entities/Payment';
import { IPaymentRepository } from '../../domain/repositories/IPaymentRepository';
import { IAppointmentRepository } from '../../domain/repositories/IAppointmentRepository';
import { IPaymentDomainService } from '../../domain/services/IDomainServices';

export interface ProcessPaymentDTO {
  appointmentId: string;
  userId: string;
  amount: number;
  currency: string;
  paymentMethod: PaymentMethod;
  transactionId?: string;
}

export interface ProcessPaymentResult {
  payment: Payment;
  success: boolean;
  error?: string;
}

export class ProcessPaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly appointmentRepository: IAppointmentRepository,
    private readonly paymentDomainService: IPaymentDomainService
  ) {}

  async execute(data: ProcessPaymentDTO): Promise<ProcessPaymentResult> {
    try {
      // Validate appointment exists
      const appointment = await this.appointmentRepository.getById(data.appointmentId);
      if (!appointment) {
        return {
          payment: null as any,
          success: false,
          error: 'Appointment not found'
        };
      }

      // Check if payment is already processed
      const existingPayment = await this.paymentRepository.getPaymentByAppointment(data.appointmentId);
      if (existingPayment && existingPayment.isCompleted()) {
        return {
          payment: existingPayment,
          success: false,
          error: 'Payment already processed'
        };
      }

      // Validate payment can be processed
      const canProcessPayment = await this.paymentDomainService.canProcessPayment(
        data.userId,
        data.appointmentId
      );

      if (!canProcessPayment) {
        return {
          payment: null as any,
          success: false,
          error: 'Payment cannot be processed'
        };
      }

      // Validate payment amount
      const validAmount = await this.paymentDomainService.validatePaymentAmount(
        data.amount,
        data.appointmentId
      );

      if (!validAmount) {
        return {
          payment: null as any,
          success: false,
          error: 'Invalid payment amount'
        };
      }

      // Create payment record
      const payment = Payment.createPending({
        id: '', // Will be generated by repository
        appointmentId: data.appointmentId,
        userId: data.userId,
        amount: {
          amount: data.amount,
          currency: data.currency
        },
        paymentMethod: data.paymentMethod
      });

      const createdPayment = await this.paymentRepository.create(payment);

      // Mark appointment as paid
      await this.appointmentRepository.markAsPaid(data.appointmentId);

      // Complete the payment if transaction ID is provided
      if (data.transactionId) {
        const completedPayment = await this.paymentRepository.completePayment(
          createdPayment.id,
          data.transactionId
        );
        
        return {
          payment: completedPayment,
          success: true
        };
      }

      return {
        payment: createdPayment,
        success: true
      };
    } catch (error) {
      return {
        payment: null as any,
        success: false,
        error: error instanceof Error ? error.message : 'Payment processing failed'
      };
    }
  }

  async completePayment(paymentId: string, transactionId: string): Promise<Payment> {
    return await this.paymentRepository.completePayment(paymentId, transactionId);
  }

  async failPayment(paymentId: string): Promise<Payment> {
    const failedPayment = await this.paymentRepository.failPayment(paymentId);
    
    // Update appointment status if payment fails
    await this.appointmentRepository.update(
      failedPayment.appointmentId,
      { status: 'pending' }
    );

    return failedPayment;
  }
}